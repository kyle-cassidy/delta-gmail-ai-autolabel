import yaml
import re
#from googleapiclient import Gmail  # You'd use the Gmail API

# Load the YAML files (as you've already started)
with open("product_categories.yaml", "r") as f:
    product_categories = yaml.safe_load(f)
with open("regulatory_actions.yaml", "r") as f:
    regulatory_actions = yaml.safe_load(f)
with open("clients.yaml", "r") as f:
    clients = yaml.safe_load(f)
# Load state_specific.yaml (when created)
# with open("state_specific.yaml", "r") as f:
   # state_specific = yaml.safe_load(f)

def classify_email(email_text, sender_email, to_emails, cc_emails, email_subject):
    labels = set()  # Use a set to avoid duplicate labels

    # --- 1. Client Identification ---
    sender_domain = sender_email.split('@')[-1]
    for client_code, client_data in clients.items():
        if sender_domain in client_data['domains']:
            labels.add(f"client:{client_code}")
            break  # Stop after the first client match
        if client_data.get('primary_contact_email') == sender_email:
            labels.add(f"client:{client_code}") #add a check for primary contact
            break

    # --- 2. Product Category and Subcategory ---
    for category, cat_data in product_categories.items():
        if re.search(cat_data['regex'], email_text, re.IGNORECASE):
            labels.add(f"product_category:{category}")
            # Check subcategories
            if 'subcategories' in cat_data:
                for subcategory, sub_data in cat_data['subcategories'].items():
                     if re.search(sub_data['regex'], email_text, re.IGNORECASE):
                        labels.add(f"subcategory:{subcategory}")
                        break  # Stop after the first subcategory match
            break  # Stop after first category match

    # --- 3. Regulatory Action ---
    for action, action_data in regulatory_actions.items():
        if re.search(action_data['regex'], email_text, re.IGNORECASE):
            labels.add(f"action:{action}")
             # Check the Email Subject
            if re.search(action_data['regex'], email_subject, re.IGNORECASE):
                labels.add(f"action:{action}") # If the subject also matches, less likely to be wrong
            break
    
    # --- 4 State ---
    for state_code in ["AL", "AK", "AZ", "AR", "CA", "CO", "CT", "DE", "FL", "GA",
                    "HI", "ID", "IL", "IN", "IA", "KS", "KY", "LA", "ME", "MD",
                    "MA", "MI", "MN", "MS", "MO", "MT", "NE", "NV", "NH", "NJ",
                    "NM", "NY", "NC", "ND", "OH", "OK", "OR", "PA", "RI", "SC",
                    "SD", "TN", "TX", "UT", "VT", "VA", "WA", "WV", "WY", "DC"]:
        if re.search(f"\\b{state_code}\\b", email_text): #Using the state 2 letter abbreviation, check if in email
            labels.add(f"state:{state_code}")
    
    # --- 5. Check for State Specific Terms (after main categories) ---
    # This helps override general categories with specifics.
    if 'state' in labels:  # Only proceed if a state has been identified.
       state = labels.intersection(set([f"state:{s}" for s in ["AL", "AK", "AZ", "AR", "CA", "CO", "CT", "DE", "DC", "FL", "GA", "HI", "ID", "IL", "IN", "IA", "KS", "KY", "LA", "ME", "MD", "MA", "MI", "MN", "MS", "MO", "MT", "NC", "ND", "NE", "NH", "NJ", "NM", "NV", "NY", "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN", "TX", "UT", "VA", "VT", "WA", "WV", "WY"]])).pop().split(":")[1] #Extract just 2 letter state code
       for category, cat_data in product_categories.items():
            if 'subcategories' in cat_data:
                for subcategory, sub_data in cat_data['subcategories'].items():
                     if 'state_terms' in sub_data:
                        for term_data in sub_data['state_terms']:
                            if state in term_data['states']:
                                if re.search(f"\\b(?i){term_data['term']}\\b", email_text):
                                    labels.add(f"product_category:{category}") #